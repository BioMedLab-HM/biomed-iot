"""
This script automates the installation and setup of the Biomed IoT platform,
including pre-checks, user input for configuration, installation of necessary
packages (Docker, Node-RED, InfluxDB, Grafana, Mosquitto, PostgreSQL, Django,
Gunicorn, and NGINX), and final configuration.

The setup_files subfolder includes additional setup scripts that the main setup
process calls. These scripts are responsible for installing various components
of Biomed IoT.

The setup_files/config subfolder holds configuration files for the various
services being installed.

The setup_files/setup_logs subfolder stores log files generated by both this main
setup script and the individual installation scripts.
"""

import os
import sys
import socket
import platform
import re
import time
import zipfile
from getpass import getpass
from setup_files.setup_utils import (
    run_bash,
    get_linux_user,
    get_setup_dir,
    log,
    set_setup_dir_rights,
    get_random_string,
    get_conf_path
)
from setup_files.write_config_file import generate_empty_config_data, write_config_file
from setup_files.install_01_basic_apt_packages import install_basic_apt_packages
from setup_files.install_02_security_packages import install_security_packages
from setup_files.install_03_docker import install_docker
from setup_files.install_04_nodered import install_nodered
from setup_files.install_05_influxdb import install_influxdb
from setup_files.install_06_grafana import install_grafana
from setup_files.install_07_mosquitto import install_mosquitto
from setup_files.install_08_postgres import install_postgres
from setup_files.install_09_django import install_django
from setup_files.install_10_gunicorn import install_gunicorn
from setup_files.install_11_nginx import install_nginx


def print_logo_header():
    logo_header = """
 ______   _                           _    _      _______
(____  \ (_)                         | |  | |    (_______)
 ____)  ) _   ___   ____   _____   __| |  | |  ___  | |
|  __  ( | | / _ \ |    \ | ___ | / _  |  | | / _ \ | |
| |__)  )| || |_| || | | || ____|( (_| |  | || |_| || |
|______/ |_| \___/ |_|_|_||_____) \____|  |_| \___/ |_|

<<<----      Setup of Biomed IoT      --->>>
<<<----       Version v1.0        --->>>
"""
    print('\n' + logo_header + '\n')
    log(logo_header + '\n')


def get_and_check_cpu_architecture():
    """Check system's CPU architecture."""
    supported_architectures = ['amd64', 'x86_64', 'arm64', 'aarch64']
    cpu_architecture = platform.machine()
    if cpu_architecture.lower() not in supported_architectures:
        msg = (
            f'Your system architecture "{cpu_architecture}" is not '
            'supported. Only "amd64", "x86_64", "arm64"or  "aarch64" is '
            'supported.\nExiting Setup'
        )
        print(msg)
        log(msg)
        sys.exit(1)

    return cpu_architecture


def get_setup_scheme():
    """Determine the setup scheme based on user input."""
    # print(
    #     '\nTLS (Transport Layer Security) encrypts data between your '
    #     'server and its users and gateways (using https), ensuring the data '
    #     'remains private and secure. It is highly recommended for most '
    #     'installations.\nIf you are in a controlled, isolated environment with '
    #     'limited resources (e.g., an older Raspberry Pi) and encryption is not '
    #     'a priority, you might consider using HTTP without TLS.\n'
    # )
    chosen_scheme = 'NO_TLS'  # Default scheme without TLS encryption
    answer = (
        input('\n\n\nEnable encryption (TLS) for your Biomed IoT server? ' '(Y/n, default is n): ').strip().lower()
    )
    if answer == 'y':
        chosen_scheme = 'TLS_NO_DOMAIN'
        # Ask about the domain
        domain_answer = (
            input("\n\n\nDo you own a domain name like 'example.com' that you want to use for your server? (y/N, default is N): ").strip().lower()
        )
        if domain_answer == 'y':
            chosen_scheme = 'TLS_DOMAIN'

    log('Chosen setup scheme: ' + chosen_scheme)
    return chosen_scheme


def confirm_proceed(question_to_ask):
    """Ask the user to confirm to proceed."""
    while True:
        user_answer = input(f'{question_to_ask} (y/n): ').strip().lower()

        if user_answer == 'y':
            break  # Exit the loop and proceed
        elif user_answer == 'n':
            msg = '\nYou declined to proceed. Exiting setup.'
            print(msg)
            log(msg)
            sys.exit(1)  # Exit the script with an error code
        else:
            print("Invalid response. Please enter 'Y' or 'N'.")


def get_confirmed_text_input(input_prompt, hidden_input=False):
    """
    Example usage:
        password = get_confirmed_text_input("Enter your password", hidden_input=True)
    """
    while True:
        print()
        if hidden_input:
            input_text = getpass(f'{input_prompt}: ')
            confirmation = getpass('Please repeat your entry: ')
        else:
            input_text = input(f'{input_prompt}: ').strip()
            confirmation = input('Please repeat your entry: ').strip()

        if not input_text:
            print('Nothing entered. Please try again.')
        elif input_text == confirmation:
            return input_text
        else:
            print('Your inputs do not match. Please try again.')


def prompt_for_password(required_length=12):
    # unused
    """
    Parameters:
    - required_length (int): The minimum required length of the password.
    Returns:
    - str: The user-provided password that meets the criteria.
    """
    password_pattern = re.compile(
        r"""
    (?=.*[A-Z])     # at least one uppercase letter
    (?=.*[a-z])     # at least one lowercase letter
    (?=.*\d)        # at least one digit
    (?=.*[!@#$%%&*()_+\-=\[\]{}|;:'"<>,.?/]) # at least one special character
    .{%d,}          # at least required_length characters
    """
        % required_length,
        re.VERBOSE,
    )

    while True:
        password = get_confirmed_text_input(
            'Enter and remember a safe '
            f'password (min length {required_length}) for your Biomed IoT admin '
            'user\nIt must contain at least one uppercase letter, one '
            'lowercase letter, one digit and one special character from '
            '!@#$%&*()_+-=[]}{|;:<>/?,',
            hidden_input=True,
        )
        if password_pattern.match(password):
            return password
        else:
            print('Password does not meet the criteria.\n')


def get_credentials_for_pw_reset():
    question = (
        "\n\n\nIf you want to use the platform's password reset function and email verification for users, you need to "
        "enter credentials for an SMTP email server with App password. \nYou can add these credentials later in "
        "/etc/biomed-iot/config.toml. There you can also set EMAIL_VERIFICATION to 'true' manually. \n"
        "\nDo you want to enter credentials now?"
    )
    while True:
        user_answer = input(f'{question} (y/n): ').strip().lower()
        if user_answer == 'y':
            pwreset_host = get_confirmed_text_input(
                "Enter the host for the website's password reset or email verification function (e.g. smtp.gmail.com)"
            )
            while True:
                try:
                    pwreset_port = int(
                        get_confirmed_text_input(
                            "Enter the port for the website's password reset function (e.g. 587)"
                        )
                    )
                    if 1 <= pwreset_port <= 65535:
                        break  # Valid port; exit loop
                    else:
                        print("Invalid port: please enter a number between 1 and 65535.")
                except ValueError:
                    print("Invalid input: please enter a valid integer for the port.")

            pwreset_email = get_confirmed_text_input(
                'Enter the email address ' "for the SMTP Server"
            )
            pwreset_pass = get_confirmed_text_input(
                'Enter the password ' "for the SMTP Server; (hidden input)",
                hidden_input=True,
            )
            msg = '\nCredentials for password reset functions have been entered'
            break
        elif user_answer == 'n':
            msg = '\nNo credentials for password reset function have been entered'
            pwreset_host = ''
            pwreset_port = ''
            pwreset_email = ''
            pwreset_pass = ''
            break
        else:
            print("Invalid response. Please enter 'Y' or 'N'.")
    print(msg)
    log(msg)
    return pwreset_host, pwreset_port, pwreset_email, pwreset_pass


def create_tmp_dir():
    # Create a temporary folder for config files within setup_dir
    tmp_dir = os.path.join(get_setup_dir(), 'setup_files', 'tmp')
    os.makedirs(tmp_dir, exist_ok=True)
    log("Directory 'setup_files/tmp' created. Path: " + tmp_dir)


def create_config_dir():
    # Create a folder for the project-wide config.toml file
    config_dir = '/etc/biomed-iot'
    os.makedirs(config_dir, exist_ok=True)
    log("Directory '/etc/biomed-iot' created. Path: " + config_dir)


def create_gateway_setup_zip_file(config_path, setup_dir, setup_scheme):
    # Define paths
    if setup_scheme == 'TLS_NO_DOMAIN':
        cert_file_path = "/etc/ssl/certs/biomed-iot.crt"
        script_file_path = f"{config_path}/gateway_setup_no_domain.sh"
    if setup_scheme == 'TLS_DOMAIN':
        script_file_path = f"{config_path}/gateway_setup_domain.sh"

    run_bash(f'cp {script_file_path} {setup_dir}/setup_files/tmp/gateway_setup.sh', show_output=False)
    script_file_path = f"{setup_dir}/setup_files/tmp/gateway_setup.sh"
    publish_example_script_file_path = f"{config_path}/publish_cpu_temp.sh"
    download_folder = "/var/www/biomed-iot/media/public_download_files"
    zip_file_path = os.path.join(download_folder, "biomed_iot_gateway.zip")

    # Create zip file
    with zipfile.ZipFile(zip_file_path, 'w') as zipf:
        if setup_scheme == 'TLS_NO_DOMAIN':
            # Add cert file
            zipf.write(cert_file_path, os.path.basename(cert_file_path))
        # Add script file
        zipf.write(script_file_path, os.path.basename(script_file_path))
        # Add publish example script
        zipf.write(publish_example_script_file_path, os.path.basename(publish_example_script_file_path))

    log(f"Created zip file: {zip_file_path}")


def main():
    """
    Content:
    - "PRE-CHECKS"
    - "USER INPUT"
    - "INSTALLATION OF SOFTWARE" (setup files in sub directory "setup_files")
    - "WRITE CONFIG FILE" (Some config data will be written during installation of software)
    - "FINAL INFORMATION OUTPUT"
    """

    hostname = socket.gethostname()
    ip_address = run_bash("hostname --all-ip-addresses | awk '{print $1}'", show_output=False)
    host_docker_internal_ip = "172.17.0.1"  # Default Docker internal IP address, can be changed later in config.toml
    linux_user = get_linux_user()
    setup_dir = get_setup_dir()
    pwreset_email = None
    pwreset_pass = None
    domain = ''
    setup_scheme = None

    print_logo_header()


    """ DO PRE-CHECKS """

    # Pre check if script is called with sudo is already done witth the import of the setup_utils module

    architecture = get_and_check_cpu_architecture()

    print("\n\nTo make sure your system is up to date, run 'sudo apt update' " "and 'sudo apt full-upgrade' before setup.\n")
    confirm_proceed('Do you want to proceed? Otherwise please update, upgrade ' 'and reboot - then start setup again.')


    """ USER INPUT """
    setup_scheme = get_setup_scheme()

    if setup_scheme == 'TLS_DOMAIN':  # TLS_DOMAIN scheme may be deprecated in the future
        domain = get_confirmed_text_input("\nEnter the domain name (e.g. 'example.com') without leading 'www.'")
        log('Entered Domain: ' + domain)
        print("\n\nTo make your website accessible at your domain, run the 'setup_nginx_domain.py' after this setup. "
            "Make sure a DNS A record is set up pointing to your server's IP address."
        )

    django_admin_email = get_confirmed_text_input('\n\nEnter email address for ' "your website's admin user")

    pwreset_host, pwreset_port, pwreset_email, pwreset_pass = get_credentials_for_pw_reset()
    email_config = {
        'RES_EMAIL_HOST': pwreset_host,
        'RES_EMAIL_PORT': pwreset_port,
        'RES_EMAIL_ADDRESS': pwreset_email,
        'RES_EMAIL_PASSWORD': pwreset_pass,
        'EMAIL_VERIFICATION': "false"
    }

    if pwreset_host != "":
        question = ("\n\n\nDo you want email verification to be active for registration of Biomed IoT platform users? "
                    "Recommended for public servers!")
        user_answer = input(f'{question} (y/n): ').strip().lower()
        log(question)

         # Prefer IPv4-mapped IPv6 addresses via gai.conf to make SMTP to mailserver work.
        file_path = "/etc/gai.conf"
        line_to_add = "precedence ::ffff:0:0/96  100\n"  # Line actually already exists in the file but is commented out

        # Append the uncommented line to the end of the file
        with open(file_path, 'a') as file:
            file.write(line_to_add)

        if user_answer == 'y':
            email_config['EMAIL_VERIFICATION'] = "true"
            msg = "Email verification for user registration activated."
            print(msg)
            log(msg)

    print(
        f"\n\n\n\nThis will install Biomed IoT to directory '{setup_dir}'"
    )
    confirm_proceed('\nDo you want to proceed?')


    """ INSTALLATION OF SOFTWARE """

    msg = '\nStarting installation of Biomed IoT. Please do not interrupt!\n\n'
    print(msg)
    log(msg)

    # Capture the start time to measure the duration of the setup routine
    start_time = time.time()

    create_tmp_dir()
    create_config_dir()

    host_config_data = {
        'IP': ip_address,
        'HOSTNAME': hostname,
        'DOMAIN': domain,
        'TLS': "true" if setup_scheme != 'NO_TLS' else "false",
        'HOST_DOCKER_INTERNAL_IP': host_docker_internal_ip
    }

    empty_config_data = generate_empty_config_data()
    write_config_file(empty_config_data)

    install_basic_apt_packages()
    print('Basic apt packages installed')
    log('Basic apt packages installed')

    install_security_packages(setup_scheme)
    print('Security Packages installed')
    log('Security Packages installed')

    install_docker()
    print('Docker installed')
    log('Docker installed')

    nodered_config_data = install_nodered(setup_scheme)
    print('Node-RED installed')
    log('Node-RED installed')

    influxdb_config_data = install_influxdb(architecture)
    print('InfluxDB installed')
    log('InfluxDB installed')

    grafana_config_data = install_grafana(
        architecture,
        setup_scheme,
        ip_address
        )
    print('Grafana installed')
    log('Grafana installed')

    mosquitto_config_data = install_mosquitto(setup_scheme)
    print('Mosquitto Broker installed')
    log('Mosquitto Broker installed')

    postgres_config_data = install_postgres()
    print('')
    log('PostgreSQL database installed')

    # Write current known config data to config.toml; essential for django setup
    current_config_data = {
        **host_config_data,
        **email_config,
        **nodered_config_data,
        **influxdb_config_data,
        **grafana_config_data,
        **mosquitto_config_data,
        **postgres_config_data,
    }
    write_config_file(current_config_data)

    set_setup_dir_rights()
    django_config_data = install_django(django_admin_email)
    print('Django installed')
    log('Django installed')

    install_gunicorn()
    print('Gunicorn installed')
    log('Gunicorn installed')

    install_nginx(setup_scheme, domain, ip_address, hostname)
    print('NGINX installed')
    log('NGINX installed')

    if setup_scheme != "NO_TLS":
        config_path = get_conf_path()
        create_gateway_setup_zip_file(config_path, setup_scheme)

    # Delete the tmp directory itself and its contents using the 'rm -rf' command
    # run_bash(f'rm -rf {setup_dir}/setup_files/tmp', show_output=False)

    set_setup_dir_rights()


    """WRITE CONFIG FILE"""

    all_config_data = {
        **host_config_data,
        **email_config,
        **nodered_config_data,
        **influxdb_config_data,
        **grafana_config_data,
        **mosquitto_config_data,
        **postgres_config_data,
        **django_config_data,
    }

    write_config_file(all_config_data)

    # Capture the end time and calculate the total time taken for setup.
    end_time = time.time()
    setup_duration = end_time - start_time
    num_minutes = int(setup_duration // 60)
    num_seconds = setup_duration % 60


    """ FINAL INFORMATION OUTPUT """

    print('\n\n\n\n____________________________')
    print('\n\nThe setup of Biomed IoT has completed in\n' f'{num_minutes} min and {num_seconds} s.')

    print("\n\nAccess your website's admin user credentials in '/etc/biomed-iot/config.toml'.")

    msg_no_tls = f'The website is accessible at http://{ip_address}'
    msg_tls_no_domain = f'The website is accessible at https://{ip_address}'
    msg_tls_domain = (f"To make the website accessible at https://{domain},"
                      "follow the instructions in DOMAIN_SETUP.md directly after this setup.\n"
    )

    if setup_scheme == 'NO_TLS':
        print(msg_no_tls)
        log(msg_no_tls)
    elif setup_scheme == 'TLS_NO_DOMAIN':
        print(msg_tls_no_domain)
        log(msg_tls_no_domain)
    else:
        print(msg_tls_domain)
        log(msg_tls_domain)

    print(
        '\nFor detailed information on the installation process, '
        f'please refer to the log files located in {setup_dir}/setup_files/setup_logs.\n'
        "\nTo make everything work after this setup and the optional domain setup is finished, " \
        "please reboot your machine with 'sudo reboot'."
    )

    print('\n--- END OF SETUP ---\n\n')


if __name__ == '__main__':
    main()
